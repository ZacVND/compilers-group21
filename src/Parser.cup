import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

parser code {:
  public boolean syntaxErrors;

  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex,sf);
    lexer = lex;
  }

  public void syntax_error(Symbol current_token) {
    syntaxErrors = true;
    report_error("Syntax error at line " + (current_token.left+1) + ", column "
    + current_token.right + ": ", null);
  }

:};

terminal IN;

// IO
terminal READ, PRINT;

// Function
terminal QMARK;
terminal RETURN;

// Conditional Statements
terminal LOOP, POOL;
terminal IF, THEN, FI;
terminal BREAK, ELSE;  // Conditional Statements - Control
terminal BINOP, BBINOP, BUNOP; // BINOP = binary op, BBINOP = logical op, BUNOP = unary op

// Logical Operators
terminal EQ, GT, LT, LEQ, GEQ, NEQ;
terminal NOT, AND, OR, IMPLICATION;

// Types
terminal INT, FLOAT, RAT;
terminal SEQ, DICT;
terminal BOOLEAN;
terminal CHAR;
terminal STRING;
terminal TOP;

// Definitions
terminal TDEF, FDEF; // Define type & functions
terminal ALIAS;
terminal MAIN;
terminal IDENTIFIER;
terminal ASSIGN;

// Literals
terminal BOOLEAN_LITERAL;
terminal NULL_LITERAL;
terminal INTEGER_LITERAL, FLOATING_POINT_LITERAL, RATIONAL_LITERAL;  // Numbers
terminal STRING_LITERAL, CHARACTER_LITERAL;  // String & Char

// Separators
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK;
terminal SEMICOLON;
terminal COMMA;
terminal DOT;

// Dictionary & Sequence
terminal COLON, COLONCOLON;

// Operators
terminal PLUS, MINUS, MULT, DIV, EXP;

// Non Terminals
non terminal program;
non terminal main, function_inner, stmt, expr, expr_list, term, cond, cond_inner, loop;
non terminal typedef, typedef_inner, funcdef, function_call;
non terminal dict_type, seq_type, primitive, dict_literal, dict_literal_inner, seq_literal, seq_literal_term, seq_literal_inner, all_literals, all_types, seq_concat, seq_concat_term, identifier, comp;


// Precedences
precedence left ASSIGN;
precedence left BINOP, BUNOP, BBINOP;
precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence left EXP;

program ::= main function_inner | function_inner main | function_inner main function_inner | main;

stmt ::= identifier ASSIGN expr_list SEMICOLON //assignment
    | identifier COLON all_types SEMICOLON //declaration
    | identifier COLON identifier SEMICOLON //declaration
    | identifier COLON all_types ASSIGN expr_list SEMICOLON //initialisation
    | identifier COLON identifier ASSIGN expr_list SEMICOLON //initialisation
    | function_call SEMICOLON //function calls
    | READ identifier SEMICOLON //input
    | PRINT expr SEMICOLON //output
    | ALIAS identifier identifier SEMICOLON //alias for custom types
    | ALIAS all_types identifier SEMICOLON //alias
    | ALIAS all_types all_types SEMICOLON //alias
    | BREAK SEMICOLON
    | BREAK INTEGER_LITERAL SEMICOLON
    | typedef
    | funcdef
    | cond //conditional - if then, if then else
    | loop
    | RETURN expr SEMICOLON
    | RETURN SEMICOLON
    ;

main ::= MAIN LBRACE function_inner RBRACE SEMICOLON
    ;

function_inner ::= stmt
    | function_inner stmt
    ;

loop ::= LOOP function_inner POOL
    ;

typedef ::= TDEF identifier LBRACE typedef_inner RBRACE SEMICOLON
    ;

typedef_inner ::= identifier COLON identifier
    | identifier COLON all_types
    | identifier COLON identifier COMMA typedef_inner
    | identifier COLON all_types COMMA typedef_inner
    ;

funcdef ::= FDEF identifier LPAREN typedef_inner RPAREN LBRACE function_inner RBRACE
    | FDEF identifier LPAREN typedef_inner RPAREN LBRACE function_inner RBRACE COLON all_types SEMICOLON
    ;

function_call ::= QMARK expr QMARK IDENTIFIER LPAREN expr_list RPAREN
    ;

cond ::= IF LPAREN cond_inner RPAREN THEN stmt FI
    | IF LPAREN cond_inner RPAREN THEN stmt ELSE FI
    ;

cond_inner ::= BOOLEAN_LITERAL
    | expr BBINOP expr
    | expr comp expr
    | BUNOP cond_inner
    ;

expr_list ::= expr
    | expr COMMA expr_list
    ;

expr ::= expr BINOP expr
    | expr BBINOP expr
    | BUNOP expr
    | LPAREN expr RPAREN
    | seq_concat
    | term
    ;

term ::= all_literals
    | dict_literal
    | seq_literal
    | identifier
    | function_call
    ;

all_literals ::= INTEGER_LITERAL
    | FLOATING_POINT_LITERAL
    | RATIONAL_LITERAL
    | STRING_LITERAL
    | CHARACTER_LITERAL
    | BOOLEAN_LITERAL
    ;

all_types ::= dict_type
    | seq_type
    | primitive
    ;

dict_type ::= DICT LT primitive COMMA primitive GT
    | DICT LT TOP COMMA TOP GT
    | DICT LT TOP COMMA primitive GT
    | DICT LT primitive COMMA TOP GT
    ;

seq_type ::= SEQ LT primitive GT
    | SEQ LT TOP GT
    | SEQ LT identifier GT
    ;

primitive ::= CHAR
    | STRING
    | INT
    | FLOAT
    | RAT
    | BOOLEAN
    ;

dict_literal ::= LBRACE dict_literal_inner RBRACE
    | LBRACE RBRACE
    ;

dict_literal_inner ::= all_literals COLON all_literals
    | all_literals COLON all_literals COMMA dict_literal_inner
    ;

seq_literal ::= LBRACK seq_literal_inner RBRACK
    | LBRACK seq_literal_term COLON seq_literal_term RBRACK
    | LBRACK seq_literal_term COLON RBRACK
    | LBRACK COLON seq_literal_term RBRACK
    | identifier seq_literal
    | LBRACK RBRACK
    ;

seq_literal_term ::= identifier
    | all_literals
    ;

seq_literal_inner ::= all_literals
    | identifier
    | identifier COMMA seq_literal_inner
    | all_literals COMMA seq_literal_inner
    ;

seq_concat ::= seq_concat_term COLONCOLON seq_concat_term
    | seq_concat_term COLONCOLON seq_concat
    ;

seq_concat_term ::= identifier
    | all_literals
    | seq_literal
    | dict_literal
    ;

identifier ::= IDENTIFIER
    | IDENTIFIER DOT identifier
    ;

comp ::= EQ
    | GT
    | LT
    | LEQ
    | GEQ
    | NEQ
    ;
