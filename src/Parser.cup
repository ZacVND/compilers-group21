import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

parser code {:
  public boolean syntaxErrors;

  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex,sf);
    lexer = lex;
  }
:};

terminal IN;  // What is this supposed to do ????

// IO
terminal READ, PRINT;

// Conditional Statements
terminal LOOP, POOL;
terminal IF, FI;
terminal BREAK, ELSE;  // Conditional Statements - Control
terminal BINOP, BBINOP, BUNOP; // Logical Comparators - Type

// Logical Operators
terminal EQ, GT, LT, LEQ, GEQ, NEQ;
terminal NOT, AND, OR, IMPLICATION;
terminal TYPE;
terminal COMP;
terminal QMARK;

// Types
terminal INT, FLOAT, RAT;
terminal SEQ, DICT;
terminal BOOLEAN;
terminal CHAR;
terminal TOP;

// Definitions
terminal TDEF, FDEG; // Define type & functions
terminal ALIAS;
terminal MAIN;
terminal IDENTIFIER;
terminal ASSIGN;

// Literals
terminal BOOLEAN_LITERAL;
terminal NULL_LITERAL;
terminal INTEGER_LITERAL, FLOATING_POINT_LITERAL, RATIONAL_LITERAL;  // Numbers
terminal STRING_LITERAL, CHARACTER_LITERAL;  // String & Char

// Separators
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBARACK, RBRACK;
terminal SEMICOLON;
terminal COMMA;
terminal DOT;

// Dictionary & Sequence
terminal COLON, COLONCOLON;

// Operators
terminal PLUS, MINUS, MULT, DIV, XOR, EXP;

non terminal cond, con_inner;
non terminal stmt, expr, term, type, dict_type, seq_type, primitive, dict_literal, dict_literal_inner, seq_literal, seq_literal_inner, all_literals;
non terminal input_output_literal;

stmt ::= SEMICOLON
    | IDENTIFIER ASSIGN expr SEMICOLON
    | TDEF IDENTIFIER SEMICOLON
    | ALIAS type IDENTIFIER SEMICOLON
    ;

cond_literal ::= IF cond stmt FI
    | IF cond stmt ctrl_else FI
    ;

ctrl_else ::= ELSE LBRACE stmt RBRACE
    | cond_control_flow_else cond_control_flow_else
    ;

cond ::= BOOLEAN_LITERAL
    | LPAREN cond RPAREN
    | expr EQ expr
    | expr GT expr
    | expr LT expr
    | expr LEQ expr
    | expr GEQ expr
    | expr NEQ expr
    | NOT cond
    | cond AND cond
    | cond OR cond
    | cond IMPLICATION cond
    ;

expr ::= expr PLUS term
    | expr MINUS term
    | expr MULT term
    | expr DIV term
    | expr XOR term
    | term
    ;

term ::= LPAREN term RPAREN
    | INTEGER_LITERAL
    | FLOATING_POINT_LITERAL
    | RATIONAL_LITERAL
    ;

all_literals ::= INTEGER_LITERAL
    | FLOATING_POINT_LITERAL
    | RATIONAL_LITERAL
    | STRING_LITERAL
    | CHARLITERAL
    | BOOLEAN_LITERAL
    ;

type ::= dict_type
    | seq_type
    | primitive
    ;

dict_type ::= DICT LT primitive COMMA primitive GT
    | DICT LT TOP COMMA TOP GT
    | DICT LT TOP COMMA primitive GT
    | DICT LT primitive COMMA TOP GT
    ;

seq_type ::= SEQ LT primitive GT
    | SEQ LT TOP GT
    ;

primitive ::= CHAR
    | INT
    | FLOAT
    | RAT
    | BOOLEAN
    ;

dict_literal ::= LBRACE dict_literal_inner RBRACE
    | LBRACE RBRACE
    ;

dict_literal_inner ::= all_literals COLON all_literals
    | all_literals COLON primitive
    | dict_literal_inner COMMA dict_literal_inner
    ;

seq_literal ::= LBRACK seq_literal_inner RBRACK
    | STRING_LITERAL
    | LBRACK RBRACK
    ;

seq_literal_inner ::= all_literals
    | seq_literal_inner COMMA seq_literal_inner
    | seq_literal_inner COMMA seq_literal
    ;

input_output_literal ::= READ
    | PRINT
    ;